#redis.md

redis是基于键值对的数据结构服务器，包括字符串，哈希，列表，集合，有序集合和位图数据，有持久化，主从复制，高可用，分布式和水平扩容等特征。键过期，发布订阅，事务，流水线，Lua脚本等功能。
redis.conf配置修改 daemonize yes允许后台运行 bind 0.0.0.0 允许所有远程访问 

高可用指服务器可以正常访问的时间，在redis实现高可用技术包括持久化，复制，哨兵和集群。
sentinel功能包括主节点存活检测，主从运行情况监测，自动故障转移，主从切换
sentinel在一定时间内没有收到目标节点的回复则判断该节点主观下线，标为SDOWN,客观下线只适用于主节点，当一个哨兵判断主节点主观下线时会向其他哨兵询问，如果超过quorum个判断主节点不可达，则判定主节点客观下线,标为ODOWN。
每个哨兵每秒一次向主副节点以及其他哨兵发送ping，当协商主节点处于SDOWN状态后，投票选出新的主节点，其他从节点进行数据复制。哨兵通过pub/sub系统实现通信。

缓存优势 支持高性能高并发  
可能不良后果
	缓存与数据库双写不一致：使用cache aside pattern 更新时先更新数据库，再删除缓存。可能出现删除缓存失败仍保留旧数据，可以通过双删（更新前后都删除缓存）解决。
	缓存雪崩：缓存宕机，大量请求落在数据库使数据库崩溃。解决方案：事前，redis高可用，哨兵集群。事中，本地缓存+限流降级。事后，redis持久化，快速恢复缓存。
	缓存穿透：恶意请求不存在的key落在数据库。解决：写对应key的空值到缓存
	缓存击穿：热点key过期瞬间大量key请求数据库。解决：设置永不过期或定时重新构建热点的缓存。
	缓存并发竞争：多个客户端同时并发修改key。解决：zookeeper分布式锁；写入缓存的数据带上从mysql中查出的时间戳。
redis IO复用模型
	文件事务处理器为单线程，分为IO多路复用程序，多个socket，文件事件分派器，事件处理器四个部分。复用程序监听多个socket，将产生事件的socket放入队列中，由分派器处理。

	过期策略：定期删除+惰性删除  
	定期抽取一些key检查删除 内存耗尽时LRU内存淘汰机制  


redis集群方案
	*客户端分区方案 配置简单，容易线性扩展，但无法动态增删服务节点，无连接共享，造成连接浪费
	代理分区方案 代理组件解析客户端的数据并转发到正确的节点
	查询路由方案 在客户端的帮助下重定向到正确的节点
	数据分区
		哈希分区 redis采用，离散程度好，无法顺序访问
			节点取余分区 扩容时导致数据迁移
			一致性哈希分区 使用少量节点时加减节点变化仍很大，数据负载不均衡
			虚拟槽分区 槽数远远大于节点数，数据分布均匀，加减节点时移动哈希槽不会停止服务。redis采用，槽数0～16383
			redis集群只支持在同一槽上的key批量操作，只支持key在同一节点上的事务操作，只能使用一个数据库空间db0，key作为数据分区的最小粒度，不能把hash\list等大键值对象映射到不同节点
			常用命令
				keys遍历查看所有键
				dbsize直接返回键总数
				type key键的数据结构类型
			单线程架构+IO多路复用模型
				纯内存访问
				非阻塞IO 将epoll中的连接、读写、关闭都转换为事件，不用在网络IO上浪费过多时间
				单线程避免线程切换和竞态产生的损耗
	数据结构
		字符串 内部编码
			int 8个字节长整型
			embstr 小于等于39字节字符串
			raw 大于39字节字符串
		哈希 key field-value 
			压缩列表 ziplist 哈希类型元素个数小于512个，同时所有值都小于64字节，使用更加紧凑的结构实现多个元素的连续存储
			哈希表 hashtable 
			三种缓存方式
				原生字符串 给每个属性分配一个键，会占用过多的键，信息内聚性差
				序列化字符串类型 合理序列化提高内存使用率，但序列化与反序列化开销大
				哈希类型 减少内存空间使用，但hashtable会消耗更多内存
		列表
			阻塞操作 blpop brpop
			内部编码
			ziplist 
			链表 linnkedlist
			应用场景
				阻塞消息队列
				文章列表 
		集合 内部编码
			intset 整数集合 元
redis集群配置
节点间内部通信机制
	通信原理：集中式 zookeeper 时效性好，但更新压力都集中在一个地方，可能对元数据存储有压力
	gossip协议 redis 更新分散，通过ping ponng meet 等交流
	slavennode 初次连接全量复制，master在本地生成rdb快照文件发送给slave，slave清空就数据后加载rdb到自己内存中。
持久化方式
	RDB 对数据周期性的持久化 适合做冷备，fork子进程执行持久化从而对服务影响很小，保持高性能。生成快照文件宕机会丢失最近数据
	AOF 数据更加完整，同时开启RDB与AOF会用AOF恢复数据。 以append-onnly写入，写入性能高适合误删除数据恢复。文件更脆弱，健壮性差
	用AOF保证数据不丢失，在AOF不可用时用RDB冷备快速恢复  
redis分布式锁
	最普通锁：set key value [EX] [PX] NX nx表示key不存在时才会设置成功，ex px为过期时间 value选择随机数，执行完成后判断value相同时才可以删掉key，否则可能因为过期而删掉其他新的key
	redLock算法 对redis集群创建锁，尝试在大多数节点上建立锁，建锁失败需要将以前建立的锁删除。别人建立了一把分布式锁，你就得不断轮询去尝试获取锁
消息队列
	用途：解耦、异步（前端直接返回，系统反应变快）、削峰
	坏处：系统可用性降低、系统复杂性增大（信息丢失、重复消费）、一致性问题（生产者返回成功而消费者消费失败）
	RabbitMQ RocketMQ Kafka
	RabbitMQ高可用 单机模式 普通集群模式 镜像集群模式（高可用，每个机器上都有所有数据）
	Kafka高可用 每个topic分为多个partition，复制多个分布在不同的节点上，选出一个leaader。读写都在leader上进行
	消息队列可能出现重复消费，如何保证幂等性：数据有主键时可以检查主键，没有唯一键时可以建立一个唯一键。
	消息丢失
		rabbitMQ：生产者丢失，可以采用connfirm确认机制，没收到确认重发。RabbitMQ丢失，采用持久化queue和信息，持久化完成后才确认收到信息。消费者丢失，关闭MMQ的自动ack，消费完后再在程序中调用ack。
		kafka：生产者不会丢失，因为需要所有的follower确认写入成功。消费者丢失，关闭自动提交offset。kafka弄丢，同生产者，需设置acks=all使所有follower确认收到信息。
	针对同一数据的几个操作消费顺序错乱
		RabbitMQ:拆分多个queue，每个queue用一个消费者处理，消费者内部使用内存队列排队处理保证顺序
		kafka：对同一数据而言一定会发送到同一partition中，但一个partitionn不能只用一个线程，吞吐量太低。因此对每个partitionn建立多个内存queue，每个线程消费一个queue，保证顺序性。
高并发系统：分库分表
	分表：单表数据量太大影响sql查询性能
	分库：单库支撑并发一般最高2000，一般1000左右
	水平拆分：把表中的数据拆到多个库多个表中，满足更高并发与扩容
	垂直拆分：把很多字段的表拆成多个表，一般把较少的访问频率高的字段放入一个表，从而使高访问频率字段能存储更多的行
	分库分表中间件自动路由到对应的库表
	分库分表方案
		停机迁移
		双写迁移：写数据时在两个表都写入，之后将老库数据写到新库，并做校验
	动态扩容分库分表方案
		每次扩容时按倍数扩容，分配到哈希值新表
	id主键处理
		数据库自增id：需要并发度不是很高的条件，否则一样面临高并发问题
		设置表自增字段步长：新增服务节点时面临困难
		获取系统当前时间拼接
		snowflake算法：时间戳+机器编号+同时间同机器给的编号
mysql读写分离通过主从复制实现，主库将变更写入binlog日志，从库连接主库后读取binlog到relay日志，主库中的并行操作将在从库中串行操作，所以在高并发下会有主从延时，刚写入主库的数据是读不到的。
mysql通过半同步复制解决主库数据丢失问题，主库写入后立即同步给从库，从库写入relay后返回aack，主库接收到至少一个从库的ack才认为写入成功。采用并行复制解决主从延时问题，从库开启多个线程并行读取不同库的日志，并行写入
高并发系统设计
	系统拆分、缓存、MQ、分库分表、读写分离、es
分布式框架
	dubbo原理 
		1.service层，provider 与connsumer接口，用来实现
		2.config配置层，配置文件
		3.proxy服务代理层，生成代理进行网络通信。
		4.register服务注册层，负责服务的注册与发现
		5.cluster集群层，封装provider提供的路由组成集群，负载均衡
		6.moniter监控层，对rpc接口调用信息监控
		7.protocal远程调用层，负责网络通信
		8.exchange信息交换层，封装请求响应模式
		9.transport网络传输层
		10.serialize数据序列化层
		工作流程：provider到注册中心注册，connsummer订阅服务，注册中心会通知consumer,consummer调用provider,异步通知监控中心
zookeeper
	分布式协调：A发送请求后可以在节点上某个值设置监听器，当请求被消费之后收到通知
	分布式锁：创建znnode作为分布式锁
	元数据/配置信息管理
	HA高可用性
	zk分布式锁 注册监听器监听znode
高可用架构hystrix 对依赖服务调用出现的延迟与失败进行控制容错
